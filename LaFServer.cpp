#include "LaFServer.h"#include "LaFCommon.h"#include "MuS.h"#include <iostream>#include <string>#include <vector>#include <map>#include <unordered_map>#include <cstring>#include <thread>#include <mutex>#include <algorithm>#include <sstream>#include <set>#include <chrono>#include "NewHope512cpa/api.h"#include "NewHope512cpa/rng.h"extern "C"{#include <openssl/sha.h>#include <openssl/rand.h>#include <openssl/aes.h>#include <netinet/in.h>#include <netinet/tcp.h>#include <sys/socket.h>#include <sys/types.h>#include <arpa/inet.h>#include <unistd.h>}using std::cout;using std::cerr;using std::endl;static std::mutex mtx_pk, mtx_ss_cip_c, mtx_ss_cip_s, mtx_arr_e, mtx_arr_MuS, mtx_Pprime, mtx_arr_y_pi, mtx_arr_sp_seed, mtx_arr_sp_b, mtx_time_key_exchange, mtx_time_share_twomasks, mtx_time_maskinputs, mtx_time_recover, mtx_aggred_data, mtx_band_keyex, mtx_band_share, mtx_band_input, mtx_band_recover;static map<int, string> prt_pk_c, prt_pk_s, arr_v_seed, arr_Lambda_seed, arr_A_seed, arr_v_b, arr_Lambda_b, arr_A_b, arr_y_pi;static map<string, string> ss_cip_c, ss_cip_s;static map<int, map<int, string>> arr_e, arr_sp_seed, arr_sp_b;static vector<int> Pprime;static std::set<int> recover_user;volatile int current_identity, current_epoch, finished_parties;static volatile bool aggregration_started = false, aggregation_finished = false;static map<int, double> time_key_exchange, time_share_two_masks, time_maskinputs, time_recover;static std::string aggred_data;static volatile int thread_id;static volatile int bandwidth_keyex, bandiwdth_share, bandwidth_input, bandwidth_recover;void recover_ss(map<int, map<int, string>> &out){    MuS mus;    for (int i = 1; i <= MSSS_N; i++)    {        unsigned char _pk[CRYPTO_PUBLICKEYBYTES], _sk[CRYPTO_SECRETKEYBYTES], _e[CRYPTO_SECRETKEYBYTES], seed[96];        vec_ZZ_p S, v;        vector<vec_ZZ_p> sp;        vector<int> p;        mat_ZZ_p Lambda, A;        std::stringstream sstream;        map<int, string> tmp_map;        if (std::find(Pprime.begin(), Pprime.end(), i) != Pprime.end())            continue;        for (const auto &itr: arr_sp_seed[i])        {            vec_ZZ_p tmp;            p.emplace_back(itr.first);            vec_zz_p_from_string(tmp, itr.second);            sp.emplace_back(tmp);        }        mat_zz_p_from_string(Lambda, arr_Lambda_seed[i]);        mat_zz_p_from_string(A, arr_A_seed[i]);        vec_zz_p_from_string(v, arr_v_seed[i]);        mus.Recover(S, p, sp, v, Lambda, A, MSSS_T, MSSS_N);        TransToBit(seed, S);        LaF_cpapke_keypair(_pk, _sk, _e, seed, true);        for (int j = 1; j <= MSSS_N; j++)        {            string tmp, tmp1;            if (j < i)            {                tmp1 = std::to_string(i) + "@" + std::to_string(j);                LaF_cpapke_rec(seed, (const unsigned char *) ss_cip_s[tmp1].c_str(), _pk, _sk, _e);            }            else if (j > i)            {                tmp1 = std::to_string(j) + "@" + std::to_string(i);                LaF_cpapke_dec(seed, (const unsigned char *) ss_cip_s[tmp1].c_str(), _sk);            }            tmp.assign((const char *) seed, 32);            tmp_map[j] = tmp;        }        out[i] = tmp_map;    }}void recover_b(map<int, vec_ZZ_p> &out){    MuS mus;    for (int i: Pprime)    {        vec_ZZ_p S, v;        vector<vec_ZZ_p> sp;        vector<int> p;        mat_ZZ_p Lambda, A;        std::stringstream sstream;        string tmp;        int counter=0;        for (const auto &itr: arr_sp_b[i])        {            vec_ZZ_p vec_tmp;            p.emplace_back(itr.first);            vec_zz_p_from_string(vec_tmp, itr.second);            sp.emplace_back(vec_tmp);            counter++;            if(counter>=MSSS_T)                break;        }        mat_zz_p_from_string(Lambda, arr_Lambda_b[i]);        mat_zz_p_from_string(A, arr_A_b[i]);        vec_zz_p_from_string(v, arr_v_b[i]);        mus.Recover(S, p, sp, v, Lambda, A, MSSS_T, MSSS_N);        out[i] = S;    }}void do_clear_after_aggregation(){    double max_time_key_exchange = 0, max_time_share_two_masks = 0, max_time_maskinputs = 0, max_time_recover = 0;    for (const auto &itr: time_key_exchange)        if (max_time_key_exchange < itr.second)            max_time_key_exchange = itr.second;    for (const auto &itr: time_share_two_masks)        if (max_time_share_two_masks < itr.second)            max_time_share_two_masks = itr.second;    for (const auto &itr: time_maskinputs)        if (max_time_maskinputs < itr.second)            max_time_maskinputs = itr.second;    for (const auto &itr: time_recover)        if (max_time_recover < itr.second)            max_time_recover = itr.second;    cout << "Key Exchange time: " << max_time_key_exchange << endl;    cout << "Share Two Masks time: " << max_time_share_two_masks << endl;    cout << "Mask Inputs time: " << max_time_maskinputs << endl;    cout << "Recover time: " << max_time_recover << endl;    cout << "------------------------------------" << endl;    cout << "Key Exchange bandwidth: " << bandwidth_keyex << endl;    cout << "Share Two Masks bandwidth: " << bandiwdth_share << endl;    cout << "Mask Inputs bandwidth: " << bandwidth_input << endl;    cout << "Recover bandwidth: " << bandwidth_recover << endl;    finished_parties = 0;    prt_pk_s.clear();    recover_user.clear();    Pprime.clear();    time_key_exchange.clear();    time_maskinputs.clear();    time_recover.clear();    time_share_two_masks.clear();    aggregation_finished = false;    aggregration_started = false;    arr_y_pi.clear();    current_epoch++;    bandiwdth_share = 0;    bandwidth_input= 0;    bandwidth_keyex = 0;    bandwidth_recover = 0;}void do_secure_aggregration(){    map<int, map<int, string>> arr_ss;    map<int, vec_ZZ_p> arr_b;    vec_RR result, tmp;    std::stringstream sstream;    recover_ss(arr_ss);    recover_b(arr_b);    vec_RR_from_string(result, arr_y_pi[Pprime[0]]);    for (int i = 1; i < Pprime.size(); i++)    {        vec_RR tmp;        vec_RR_from_string(tmp, arr_y_pi[Pprime[i]]);        result = result + tmp;    }    for (const auto &itr: arr_b)    {        vec_RR tmp;        PRG(tmp, itr.second, result.length(), false);        result = result - tmp;    }    for (const auto &itr: arr_ss)    {        for (const auto &itr1: itr.second)        {            if (std::find(Pprime.begin(), Pprime.end(), itr1.first) == Pprime.end())                continue;            if (itr1.first < itr.first)            {                PRG(tmp, itr1.second, result.length(), false);                result = result - tmp;            }            else if (itr1.first > itr.first)            {                PRG(tmp, itr1.second, result.length(), true);                result = result - tmp;            }        }    }    cout << "Finish aggregration of epoch " << current_epoch << " : " << endl;    vec_RR_to_string(aggred_data, result);    //cout << result;    //cout << endl;    aggregation_finished = true;}void do_Init_KeyExchange_SavePk_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band =0;    string tmp;    mtx_pk.lock();    int id = current_identity;    current_identity++;    mtx_pk.unlock();    begin = std::chrono::steady_clock::now();    cout << "client #" << id << " connect" << endl;    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_pk.lock();    prt_pk_c[id] = tmp;    mtx_pk.unlock();    send_data(sock, (unsigned char *) &id, sizeof(int));    band += sizeof(int);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_pk.lock();    prt_pk_s[id] = tmp;    mtx_pk.unlock();    send_data(sock, (unsigned char *) &id, sizeof(int));    band += sizeof(int);    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] = elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}void do_Init_KeyExchange_DistPk_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id;    string tmp, tmp1;    begin = std::chrono::steady_clock::now();    recv_data(sock, (unsigned char *) &id, sizeof(id));    send_data(sock, (unsigned char *) &id, sizeof(id));    band += 2*sizeof(id);    for (int i = 1; i < id; i++)    {        while (true)        {            mtx_pk.lock();            if (prt_pk_c.find(i) != prt_pk_c.end())            {                tmp = prt_pk_c[i];                mtx_pk.unlock();                break;            }            mtx_pk.unlock();            usleep(1000);        }        send_bytes(sock, tmp);        band += tmp.length();        tmp1 = std::to_string(id) + "@" + std::to_string(i);        recv_bytes(sock, tmp);        band += tmp.length();        mtx_ss_cip_c.lock();        ss_cip_c[tmp1] = tmp;        mtx_ss_cip_c.unlock();        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);        while (true)        {            mtx_pk.lock();            if (prt_pk_s.find(i) != prt_pk_s.end())            {                tmp = prt_pk_s[i];                mtx_pk.unlock();                break;            }            mtx_pk.unlock();            usleep(1000);        }        send_bytes(sock, tmp);        band += tmp.length();        recv_bytes(sock, tmp);        band += tmp.length();        mtx_ss_cip_s.lock();        ss_cip_s[tmp1] = tmp;        mtx_ss_cip_s.unlock();        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);    }    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] += elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}void do_Init_KeyExchange_DistCip_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id, op = 0;    string tmp, tmp1;    begin = std::chrono::steady_clock::now();    recv_data(sock, (unsigned char *) &id, sizeof(id));    send_data(sock, (unsigned char *) &op, sizeof(op));    band = 2*sizeof(int);    for (int i = id + 1; i <= MSSS_N; i++)    {        tmp1 = std::to_string(i) + "@" + std::to_string(id);        while (true)        {            mtx_ss_cip_c.lock();            if (ss_cip_c.find(tmp1) != ss_cip_c.end())            {                tmp = ss_cip_c[tmp1];                mtx_ss_cip_c.unlock();                break;            }            mtx_ss_cip_c.unlock();            usleep(1000);        }        send_bytes(sock, tmp);        band += tmp.length();        recv_data(sock, (unsigned char *) &op, sizeof(op));        band += sizeof(op);        while (true)        {            mtx_ss_cip_s.lock();            if (ss_cip_s.find(tmp1) != ss_cip_s.end())            {                tmp = ss_cip_s[tmp1];                mtx_ss_cip_s.unlock();                break;            }            mtx_ss_cip_s.unlock();            usleep(1000);        }        send_bytes(sock, tmp);        band += tmp.length();        recv_data(sock, (unsigned char *) &op, sizeof(op));        band += sizeof(op);    }    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] += elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}void do_Init_ShareTwoMasks_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id, id1;    map<int, string> tmp_map;    string tmp;    begin = std::chrono::steady_clock::now();    recv_data(sock, (unsigned char *) &id, sizeof(id));    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += 2*sizeof(int);    for (int i = 1; i < MSSS_N; i++)    {        recv_data(sock, (unsigned char *) &id1, sizeof(id1));        band += sizeof(id1);        recv_bytes(sock, tmp);        band += tmp.length();        tmp_map[id1] = tmp;        send_data(sock, (unsigned char *) &id1, sizeof(id1));        band += sizeof(id1);    }    mtx_arr_e.lock();    arr_e[id] = tmp_map;    mtx_arr_e.unlock();    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_v_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_Lambda_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_A_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_v_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_Lambda_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_A_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    id1 = MSSS_N - 1;    send_data(sock, (unsigned char *) &id1, sizeof(id1));    band += sizeof(id1);    for (int i = 1; i <= MSSS_N; i++)    {        if (i == id)            continue;        while (true)        {            mtx_arr_e.lock();            if (arr_e.find(i) != arr_e.end())            {                tmp = arr_e[i][id];                mtx_arr_e.unlock();                break;            }            mtx_arr_e.unlock();            usleep(100);        }        send_data(sock, (unsigned char *) &i, sizeof(i));        band += sizeof(i);        send_bytes(sock, tmp);        band += tmp.length();        recv_data(sock, (unsigned char *) &id1, sizeof(id1));        band += sizeof(id1);    }    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_share_twomasks.lock();    time_share_two_masks[id] = elapsed.count();    mtx_time_share_twomasks.unlock();    mtx_band_share.lock();    bandiwdth_share += band;    mtx_band_share.unlock();}void do_MaskInputs_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id, _id;    string tmp;    begin = std::chrono::steady_clock::now();    recv_data(sock, (unsigned char *) &id, sizeof(id));    send_data(sock, (unsigned char *) &id, sizeof(id));    band += 2*sizeof(int);    _id = id;    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_y_pi.lock();    arr_y_pi[id] = tmp;    mtx_arr_y_pi.unlock();    mtx_Pprime.lock();    Pprime.emplace_back(id);    mtx_Pprime.unlock();    while (true)    {        mtx_Pprime.lock();        if (Pprime.size() == MSSS_N)        {            //cout << "Pprime.size: " << Pprime.size() << endl;            mtx_Pprime.unlock();            break;        }        mtx_Pprime.unlock();        usleep(100);    }    for (int i = 0; i < Pprime.size(); i++)    {        id = Pprime[i];        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);    }    if (Pprime.size() < MSSS_N)    {        id = -1;        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);    }    recv_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_maskinputs.lock();    time_maskinputs[_id] = elapsed.count();    mtx_time_maskinputs.unlock();    aggregation_finished = false;    mtx_band_input.lock();    bandwidth_input += band;    mtx_band_input.unlock();}void do_Recover_Init_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id, tmp_int;    string tmp;    begin = std::chrono::steady_clock::now();    recv_data(sock, (unsigned char *) &id, sizeof(id));    send_data(sock, (unsigned char *) &id, sizeof(id));    //cout << id << " start recover " << endl;    band += 2*sizeof(int);    for (int i = 1; i <= MSSS_N; i++)    {        if (i == id)            continue;        recv_bytes(sock, tmp);        band += tmp.length();        if (std::find(Pprime.begin(), Pprime.end(), i) == Pprime.end())        {            map<int, string> tmp_map;            mtx_arr_sp_seed.lock();            if (arr_sp_seed.find(i) == arr_sp_seed.end())                arr_sp_seed[i] = tmp_map;            arr_sp_seed[i][id] = tmp;            mtx_arr_sp_seed.unlock();        }        else        {            map<int, string> tmp_map;            mtx_arr_sp_b.lock();            if (arr_sp_b.find(i) == arr_sp_b.end())                arr_sp_b[i] = tmp_map;            arr_sp_b[i][id] = tmp;            mtx_arr_sp_b.unlock();        }        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);    }    mtx_arr_sp_b.lock();    recover_user.emplace(id);    if (recover_user.size() < Pprime.size())    {        //cout << "user not enough (" << id << ": " << Pprime.size() << ")" << endl;        mtx_arr_sp_b.unlock();    }    else if (aggregration_started)    {        //cout << "aggregration_started " << endl;        mtx_arr_sp_b.unlock();    }    else    {        //aggregration_started = true;        thread_id = id;        cout << "start aggregation" << endl;        do_secure_aggregration();        mtx_arr_sp_b.unlock();    }    while (!aggregation_finished)    {        usleep(50);    }    send_bytes(sock, aggred_data);    band += aggred_data.length();    recv_data(sock, (unsigned char *) &tmp_int, sizeof(tmp_int));    band += sizeof(tmp_int);    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    double t = elapsed.count();    mtx_time_recover.lock();    time_recover[id] = t;    finished_parties++;    mtx_time_recover.unlock();    mtx_band_recover.lock();    bandwidth_recover += band;    mtx_band_recover.unlock();    if (id == thread_id)    {        while (finished_parties != Pprime.size())        {            usleep(10);        }        do_clear_after_aggregation();    }}void do_Cons_KeyExchange_SavePk_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    string tmp;    int id, epoch;    begin = std::chrono::steady_clock::now();    send_data(sock, (unsigned char *) &id, sizeof(id));    recv_data(sock, (unsigned char *) &id, sizeof(id));    recv_data(sock, (unsigned char *) &epoch, sizeof(epoch));    band += 3*sizeof(int);    while (epoch != current_epoch || aggregration_started)    {        usleep(100);    }    recv_bytes(sock, tmp);    band += tmp.length();    mtx_pk.lock();    prt_pk_s[id] = tmp;    mtx_pk.unlock();    send_data(sock, (unsigned char *) &id, sizeof(int));    band += sizeof(int);    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] = elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}void do_Cons_KeyExchange_DistPk_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id;    string tmp, tmp1;    begin = std::chrono::steady_clock::now();    send_data(sock, (unsigned char*)&id, sizeof(id));    recv_data(sock, (unsigned char *) &id, sizeof(id));    band += 2*sizeof(int);    for (int i = 1; i < id; i++)    {        while (true)        {            mtx_pk.lock();            if (prt_pk_s.find(i) != prt_pk_s.end())            {                tmp = prt_pk_s[i];                mtx_pk.unlock();                break;            }            mtx_pk.unlock();            usleep(100);        }        send_bytes(sock, tmp);        band += tmp.length();        tmp1 = std::to_string(id) + "@" + std::to_string(i);        recv_bytes(sock, tmp);        band += tmp.length();        mtx_ss_cip_s.lock();        ss_cip_s[tmp1] = tmp;        mtx_ss_cip_s.unlock();        send_data(sock, (unsigned char *) &id, sizeof(id));        band += sizeof(id);    }    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_v_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_Lambda_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_A_seed[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_v_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_Lambda_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    recv_bytes(sock, tmp);    band += tmp.length();    mtx_arr_MuS.lock();    arr_A_b[id] = tmp;    mtx_arr_MuS.unlock();    send_data(sock, (unsigned char *) &id, sizeof(id));    band += sizeof(id);    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] += elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}void do_Cons_KeyExchange_DistCip_(int sock){    std::chrono::steady_clock::time_point begin, end;    std::chrono::duration<double, std::micro> elapsed;    int band = 0;    int id = 0, op;    string tmp, tmp1;    begin = std::chrono::steady_clock::now();    send_data(sock, (unsigned char*)&id, sizeof(id));    recv_data(sock, (unsigned char *) &id, sizeof(id));    band += 2*sizeof(int);    for (int i = id + 1; i <= MSSS_N; i++)    {        tmp1 = std::to_string(i) + "@" + std::to_string(id);        while (true)        {            mtx_ss_cip_s.lock();            if (ss_cip_s.find(tmp1) != ss_cip_s.end())            {                tmp = ss_cip_s[tmp1];                mtx_ss_cip_s.unlock();                break;            }            mtx_ss_cip_s.unlock();            usleep(1000);        }        send_bytes(sock, tmp);        recv_data(sock, (unsigned char *) &op, sizeof(op));        band += tmp.length() + sizeof(op);    }    close(sock);    end = std::chrono::steady_clock::now();    elapsed = end - begin;    mtx_time_key_exchange.lock();    time_key_exchange[id] += elapsed.count();    mtx_time_key_exchange.unlock();    mtx_band_keyex.lock();    bandwidth_keyex += band;    mtx_band_keyex.unlock();}LaFServer::LaFServer(const string &_server_ip, int _port){    RR::SetPrecision(96);    RR::SetOutputPrecision(96);    this->server_ip = _server_ip;    this->port = _port;    current_identity = 1;    prt_pk_c.clear();    prt_pk_s.clear();    ss_cip_c.clear();    ss_cip_s.clear();    bandwidth_recover = 0;    bandwidth_input = 0;    bandiwdth_share = 0;    bandwidth_keyex = 0;}int LaFServer::ServerSockInit_(){    struct sockaddr_in srv_addr;    int sock, flag;    int buf_size = 1024 * 1024 * 10;    sock = socket(AF_INET, SOCK_STREAM, 0);    setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (const char *) &buf_size, sizeof(int));    setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (const char *) &buf_size, sizeof(int));    buf_size = 1;    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *) &buf_size, sizeof(int));    flag = 1;    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (const char *) &flag, sizeof(int));#ifndef __APPLE__    flag = 3;    setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, (const char *) &flag, sizeof(int));#endif    flag = 20;    setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, (const char *) &flag, sizeof(int));    flag = 3;    setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, (const char *) &flag, sizeof(int));    memset(&srv_addr, 0, sizeof(srv_addr));    srv_addr.sin_family = AF_INET;    srv_addr.sin_port = htons(port);    srv_addr.sin_addr.s_addr = inet_addr(server_ip.c_str());    int ret = bind(sock, (struct sockaddr *) &srv_addr, sizeof(srv_addr));    if (ret != 0)        std::cout << "Init socket failed!" << std::endl;    listen(sock, 4);    return sock;}void do_Run(int clnt_sock){    NetOp net_op;    int op_num;    recv_data(clnt_sock, (unsigned char *) &op_num, sizeof(int));    net_op = static_cast<NetOp>(op_num);    switch (net_op)    {        case NetOp_KeyExchange_init_send_pk:            do_Init_KeyExchange_SavePk_(clnt_sock);            break;        case NetOp_KeyExchange_init_recv_pk_and_gen_ss:            do_Init_KeyExchange_DistPk_(clnt_sock);            break;        case NetOp_KeyExchange_init_recv_cip_and_gen_ss:            do_Init_KeyExchange_DistCip_(clnt_sock);            break;        case NetOp_ShareTwoMasks_init:            do_Init_ShareTwoMasks_(clnt_sock);            break;        case NetOp_MaskInputs:            do_MaskInputs_(clnt_sock);            break;        case NetOp_Recover_init:            do_Recover_Init_(clnt_sock);            break;        case NetOp_KeyExchange_cons_send_pk:            do_Cons_KeyExchange_SavePk_(clnt_sock);            break;        case NetOp_KeyExchange_cons_recv_pk_and_gen_ss:            do_Cons_KeyExchange_DistPk_(clnt_sock);            break;        case NetOp_KeyExchange_cons_recv_cip_and_gen_ss:            do_Cons_KeyExchange_DistCip_(clnt_sock);            break;        default:            cerr << "Unknown operation num: " << op_num << endl;            break;    }}void LaFServer::Run(){    int sock, clnt_sock, op_num;    unsigned char buf[256];    struct sockaddr_in clnt_addr;    socklen_t socklen;    int flag = 1;    memset(&clnt_addr, 0, sizeof(struct sockaddr_in));    memset(&socklen, 0, sizeof(socklen));    sock = this->ServerSockInit_();    cout << "Server Running..." << endl;    while (1)    {        NetOp net_op;        clnt_sock = accept(sock, (struct sockaddr *) &clnt_addr, &socklen);        setsockopt(clnt_sock, SOL_SOCKET, SO_KEEPALIVE, &flag, sizeof(int));        std::thread t(do_Run, clnt_sock);        t.detach();        /*        recv_data(clnt_sock, (unsigned char *) &op_num, sizeof(int));        net_op = static_cast<NetOp>(op_num);        switch (net_op)        {            case NetOp_KeyExchange_init_send_pk:                Init_KeyExchange_SavePk_(clnt_sock);                break;            case NetOp_KeyExchange_init_recv_pk_and_gen_ss:                Init_KeyExchange_DistPk_(clnt_sock);                break;            case NetOp_KeyExchange_init_recv_cip_and_gen_ss:                Init_KeyExchange_DistCip_(clnt_sock);                break;            case NetOp_ShareTwoMasks_init:                Init_ShareTwoMasks_(clnt_sock);                break;            case NetOp_MaskInputs:                MaskInputs_(clnt_sock);                break;            case NetOp_Recover_init:                Recover_Init_(clnt_sock);                break;            case NetOp_KeyExchange_cons_send_pk:                Cons_KeyExchange_SavePk_(clnt_sock);                break;            case NetOp_KeyExchange_cons_recv_pk_and_gen_ss:                Cons_KeyExchange_DistPk_(clnt_sock);                break;            case NetOp_KeyExchange_cons_recv_cip_and_gen_ss:                Cons_KeyExchange_DistCip_(clnt_sock);                break;            default:                cerr << "Unknown operation num: " << op_num << endl;                break;        }*/    }}void LaFServer::Init_KeyExchange_SavePk_(int sock){    std::thread t(do_Init_KeyExchange_SavePk_, sock);    t.detach();}void LaFServer::Init_KeyExchange_DistPk_(int sock){    std::thread t(do_Init_KeyExchange_DistPk_, sock);    t.detach();}void LaFServer::Init_KeyExchange_DistCip_(int sock){    std::thread t(do_Init_KeyExchange_DistCip_, sock);    t.detach();}void LaFServer::Init_ShareTwoMasks_(int sock){    std::thread t(do_Init_ShareTwoMasks_, sock);    t.detach();}void LaFServer::MaskInputs_(int sock){    std::thread t(do_MaskInputs_, sock);    t.detach();}void LaFServer::Recover_Init_(int sock){    std::thread t(do_Recover_Init_, sock);    t.detach();}void LaFServer::Cons_KeyExchange_SavePk_(int sock){    std::thread t(do_Cons_KeyExchange_SavePk_, sock);    t.detach();}void LaFServer::Cons_KeyExchange_DistPk_(int sock){    std::thread t(do_Cons_KeyExchange_DistPk_, sock);    t.detach();}void LaFServer::Cons_KeyExchange_DistCip_(int sock){    std::thread t(do_Cons_KeyExchange_DistCip_, sock);    t.detach();}